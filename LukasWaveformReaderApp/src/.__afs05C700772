#include "WaveformReader.h"

void streamTask(void * driverPointer); 
void streamInit(void *driverPointer); 
void streamInit(int channel);

//WaveformReader *bayManager; //Global pointer so iocshell commands can interact with our initialized port driver
WaveformReader* WaveformReader::port_driver = nullptr;


/**
 * Initialize an ASYN Port Driver
 *
 * @param portName port for the asyn driver to use
 * @param bufferSize amount of words to read from the buffer
 * @param waveformPVs amount of EPICS waveform records our port driver should be of
 */
WaveformReader::WaveformReader(const char *portName, int bayNumber, int bufferSize, int waveformPVs) : asynPortDriver
                                                       (
                                                        portName,
                                                        1,//Max Signals?
                                                        asynDrvUserMask | asynInt32ArrayMask | asynInt16ArrayMask | asynUInt32DigitalMask | asynInt32Mask | asynFloat64Mask,
                                                        asynInt32ArrayMask | asynInt16ArrayMask | asynInt32Mask | asynUInt32DigitalMask | asynFloat64Mask,
                                                        ASYN_MULTIDEVICE | ASYN_CANBLOCK,
                                                        1,
                                                        0,
                                                        0
                                                        )
{

  //We register some useful hardware interfaces our port driver could want to know
  Path p;
  p = cpswGetRoot();
  
  _TriggerHwAutoRearm = IScalVal::create(p->findByName(("/mmio/AppTop/DaqMuxV2[" + std::to_string(bayNumber) + "]/TriggerHwAutoRearm").c_str()));
  _DataBufferSize = IScalVal::create(p->findByName(("/mmio/AppTop/DaqMuxV2[" + std::to_string(bayNumber) + "]/DataBufferSize").c_str()));
  _TrigCount = IScalVal_RO::create(p->findByName(("/mmio/AppTop/DaqMuxV2[" + std::to_string(bayNumber) + "]/TrigCount").c_str()));
  _WebInit = ICommand::create(p->findByName(("/mmio/AmcCarrierCore/AmcCarrierBsa/BsaWaveformEngine[" + std::to_string(bayNumber) + "]/WaveformEngineBuffers/Initialize").c_str()));
 
  //Connecting to the records our port driver will eventually need to interact with
  for(int pvID = 0; pvID < waveformPVs; pvID++)
  {
    //For loop generates the string identifier for each Waveform records and then creates a parameter our asynDriver can interact with for it
    int waveform_param_index;
    std::string pvIdentifier = "WAVEFORM:" + std::to_string(pvID);
    std::cout << pvIdentifier << std::endl;
    createParam(pvIdentifier.c_str(), asynParamInt16Array, &waveform_param_index);
    std::cout << "The identifier is: " << pvIdentifier << " and the waveform_param_index is : " << waveform_param_index << std::endl;
    pv_param_map.insert(std::pair<std::string, int>(pvIdentifier, waveform_param_index));
    waveform_param_indices.push_back(pvIdentifier);
    streaming_status_map[pvIdentifier] = "Not initialized yet";

    waveform_map[pvIdentifier] = (epicsInt16 *)calloc(STREAM_MAX_SIZE, sizeof(epicsInt16)); 

    // connect to the PVs that represent parameters of each waveform record using corresponding arrays
    createParam(("END_ADDR" + std::to_string(pvID)).c_str(), asynParamInt32, endAddr_indices[pvID]);
    createParam(("BEGIN_ADDR" + std::to_string(pvID)).c_str(), asynParamInt32, beginAddr_indices[pvID]);
    createParam(("START_LOC" + std::to_string(pvID)).c_str(), asynParamFloat64, start_loc_indices[pvID]);
    createParam(("END_LOC" + std::to_string(pvID)).c_str(), asynParamFloat64, end_loc_indices[pvID]);
    createParam(("BEAM_LOSS_LOC" + std::to_string(pvID)).c_str(), asynParamFloat64, beam_loss_loc_indices[pvID]);


    (*(start_addresses[pvID])) = IScalVal::create(p->findByName(("/mmio/AmcCarrierCore/AmcCarrierBsa/BsaWaveformEngine[" + std::to_string(bayNumber) + "]/WaveformEngineBuffers/StartAddr[" + std::to_string(pvID) + "]").c_str()));
    (*(end_addresses[pvID])) = IScalVal::create(p->findByName(("/mmio/AmcCarrierCore/AmcCarrierBsa/BsaWaveformEngine[" + std::to_string(bayNumber) + "]/WaveformEngineBuffers/EndAddr[" + std::to_string(pvID) + "]").c_str()));

    //retrieve hardware addresses and store them into corresponding records
    uint32_t u32_begin, u32_end;
    (*(start_addresses[pvID]))->getVal(&u32_begin, 1);
    //std::cout << "u32_begin is " << u32_begin << std::endl;
    setIntegerParam(*(beginAddr_indices[pvID]), u32_begin);
    (*(end_addresses[pvID]))->getVal(&u32_end, 1);
    //std::cout << "u32_end is " << u32_end << std::endl;
    setIntegerParam(*(endAddr_indices[pvID]), u32_end);
    callParamCallbacks();

  }

  //TODO: Do this is a more systematic way, individually connecting isn't really aesthetic 
  createParam(WAVEFORM_RUN_STRING, asynParamUInt32Digital, &waveform_run_index);
  createParam(NO_OF_WORDS_STRING, asynParamInt32, &number_of_words_index);
  createParam(WAVEFORM_BUFFER_SIZE_STRING, asynParamInt32, &waveform_buffer_size_index);
  createParam(WAVEFORM_INITIALIZE_STRING, asynParamUInt32Digital, &waveform_init_index);
  //MAX_BUFFER_SIZE = bufferSize; //One of the parameters we pass to our port driver is the bufferSize, which is essentially how many words of information we want at a time

}


/**
 * Launch a thread to stream data to an EPICS records
 *
 * @param pv_identifier string corresponding to the Epics record we wish to have data in
 * @param stream_path string form of the path to the stream we want to connect to
 *
 * Does not return
 */
void WaveformReader::streamInit(std::string pv_identifier, std::string stream_path)
{
  StreamArgs toPass; //Initialize a structure to pass the arguments we need to begin streaming

  toPass.pPvt = this;
  toPass.pv_identifier = pv_identifier;
  toPass.stream_path_to_find = stream_path; 

  //std::cout << "The path we pass is: " << toPass.stream_path_to_find << std::endl;
  //printf("\nChannel number in toPass is %d\n" ,toPass.stream);

  asynStatus status;
  status = (asynStatus)(epicsThreadCreate("WaveformTask", epicsThreadPriorityMedium, epicsThreadGetStackSize(epicsThreadStackMedium), (EPICSTHREADFUNC)::streamTask, &toPass) == NULL);
  if(status == asynError)
  {
    std::cout << "Unable to launch a waveform stream; " << status << std::endl;
  }
  else
  {
    std::cout << "Succesfully launched waveform stream=> " << pv_identifier << " status: " << status << std::endl;
  }
  sleep(3); //Sleep so the launched thread can find the structure before it's overwritten by garbage TODO: Do this in a better way 
}

/**
 * Tell a port driver to use it's streamTask method with the passed args generally called by streamInit
 *
 * @param streamArgs port driver and the required args to begin streaming
 */
void streamTask(void* streamArgs)
{
  StreamArgs *passedArgs = static_cast<StreamArgs*>(streamArgs);

  WaveformReader *pPvt = (WaveformReader *) passedArgs->pPvt;
  pPvt->streamTask(passedArgs->stream_path_to_find.c_str(), passedArgs->pv_identifier);
}

/*void WaveformReader::reset(int val)
{
  state = val;
}*/

/**
 * Connect to a stream, write the data retrieved from the stream to the specified EPICS record
 *
 * @param streamInit path to the stream to connect and read from
 * @param pvID Identifier of the EPICS record to write data from the stream to
 */
void WaveformReader::streamTask(const char *streamInit = "/Stream0", std::string pvID = "WAVEFORM:0")//, int waveform_param_index = -1)//Stream stm, int param16index, int param32index)
{
        sleep(1);

        //TODO based on streamInit, add key and param to the asynPortDriver

        std::cout << "Passed pvID: " << pvID << std::endl;
        int waveform_param_index = pv_param_map[pvID];
        std::cout << pvID << " corresponding index: " << waveform_param_index << std::endl;

        Path p;
        p = cpswGetRoot();

        std::cout << "Stream Init (path to the stream): " << streamInit << std::endl;
        Stream stm;

        try {
          stm = IStream::create(p->findByName(streamInit));
        }
        catch (CPSWError &e) {
          std::cerr << e.what() << std::endl;
        }

        if(stm)
        {
          std::cout << "Value of stm: " << stm << std::endl;
          printf("Did that thing with a stream?\n");
          streaming_status_map[pvID] = "Successfully initialized"; 
        }
        else {
          printf("No stream access");
          streaming_status_map[pvID] = "Initialization failed";
          return;
        }

        uint8_t *buf = new uint8_t[STREAM_MAX_SIZE];
        size_t nWords16, nBytes;
        int64_t got = 0;
        int64_t lastGot = 0;

        std::cout << "Outside the while loop now " << std::endl;
        std::cout << "MAX_BUFFER_SIZE is: " << MAX_BUFFER_SIZE << std::endl;
        while(1)
        {
            //std::cout << "Inside the while loop " << std::endl;
            //std::cout << streamInit << std::endl;
            //std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
            got = stm->read( buf, MAX_BUFFER_SIZE, CTimeout(-1));
            //std::chrono::steady_clock::time_point end1 = std::chrono::steady_clock::now();
            //std::cout << "No. of values read in from the stream (value of got): " << got << std::endl;
            //std::cout << "Value of lastGot: " << lastGot << std::endl;

            if(got > 8)
            {
                //printf("There's a thing in the stream? %ld bytes\n", got);
                lock();
                nBytes = (got - 9); // header = 8 bytes, footer = 1 byte, data = 32bit words.
                nWords16 = nBytes / 2; //Amount of words in our buffer to read
                if (nWords16 > 0)
                {
                  streaming_status_map[pvID] = "Successfully initialized and streaming data";
                }
                else
                {
                  streaming_status_map[pvID] = "Successfully initialized but no data in buffer";
                }
                //std::cout << "No. of words read in from the stream (after removing header and footer) : " << nWords16 << std::endl; 

                doCallbacksInt16Array((epicsInt16*)(buf + 8), nWords16, waveform_param_index, 0);

                for(int i = 0; i < MAX_BUFFER_SIZE; i++)
                {
                  /**
                   * Take data gathered from the stream and move it into an array we can play with
                   * TODO take options so we know how we'd want to modify the array
                   */
                  waveform_map[pvID][i] = (int16_t)buf[i];
                }

                //std::cout << "Size of buf: " << (sizeof(buf)/sizeof(buf[0])) << std::endl;
                //std::cout << "Size of waveformData: " << (sizeof(waveformData)/sizeof(waveformData[0])) << std::endl;
                if (lastGot > got)
                {
                  //Clear the the buffer of previously read data
                  memset(buf+got, 0, (lastGot-got)*sizeof(int8_t));
                }
                lastGot = got;
                unlock();
            }
            else
            {
                 asynPrint(pasynUserSelf, ASYN_TRACE_ERROR, "WaveformReader: Received frame too small\n");
                 streaming_status_map[pvID] = "Successfully initialized but received frame too small";
                 //std::cout << "Inside the else right now" << std::endl;
            }
            //std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
            //auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - begin);
            //printf("Getting from the buffer required %llu milliseconds\n", duration);

      }
        
    //}
    /**
    catch(IntrError &e)
    {
        delete[] buf;
    }
    **/ 
    return;
}

/**
 * Override of asyn port driver default writeUInt32Digital,lets us set hardware by writing to epics records
 */
asynStatus WaveformReader::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
  asynStatus status = setUIntDigitalParam(pasynUser->reason, value, mask);
  callParamCallbacks();
  printf("Driver calls write UInt32\n");
  if(pasynUser->reason == waveform_run_index)
  {
    printf("Value of %d\n", value);
    //Do a thing with the firmware here?????? I mean if I'm writing I just need to set the value don't I
    //This is for turning on and off so this should in theory be the TriggerHardwareAutoRearm
    //Essentially just using my ScalVal interface to tell the address to turn on or off, should be that simple according to Jeremy
    _TriggerHwAutoRearm->setVal((int64_t)value);
  }
  if(pasynUser->reason == waveform_init_index)
  {
    _WebInit->execute();
  }

  return status;
}


/**
 * Override of asyn port driver default writeInt32,lets us set hardware by writing to epics records
 */
asynStatus WaveformReader::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
  printf("Driver calls write Int32\n");
  asynStatus status = setIntegerParam(pasynUser->reason, value);
  callParamCallbacks();

  // execute instructions at hardware addresses based on which parameter of which waveform record
  // pasynUser matches with
  for (int i = 0; i < NUMBER_OF_WAVEFORM_RECORDS; i++)
  {
    if(pasynUser->reason == (*(endAddr_indices[i])))
    {
      (*(end_addresses[i]))->setVal((int64_t)value);
      _WebInit->execute();
    }

    if(pasynUser->reason == (*(beginAddr_indices[i])))
    {
      (*(start_addresses[i]))->setVal((int64_t)value);
    }
  }

  if(pasynUser->reason == waveform_buffer_size_index)
  {
    _DataBufferSize->setVal((int64_t)value);
    MAX_BUFFER_SIZE = 4 * value ;
  }

  // if the NO:OF:WORDS record updates
  if(pasynUser->reason == number_of_words_index)
  {
    int number_of_words;
    getIntegerParam(number_of_words_index, &number_of_words);

    /// TO BE TESTED
    number_of_words = ((number_of_words + 4) / 8) * 8;
    ///

    // Calculate the DaqMux Data Buffer Size (N/2)
    // Set the DaqMuxV2/DataBufferSize to N/2 (as this is expressed in 32-bit words)
    int daqMuxBufferSize = (number_of_words / 2);
    setIntegerParam(waveform_buffer_size_index, daqMuxBufferSize);
    callParamCallbacks();

    _DataBufferSize->setVal(daqMuxBufferSize);
    MAX_BUFFER_SIZE = 2 * number_of_words;
    

    int beginAddress, endAddress;

    for (int i = 0; i < NUMBER_OF_WAVEFORM_RECORDS; i++)
    {
      // get the beginning address of the stream
      getIntegerParam(*(beginAddr_indices[i]), &beginAddress);
        
      endAddress = beginAddress + (number_of_words * 2);

      setIntegerParam(*(endAddr_indices[i]), endAddress);
      callParamCallbacks();

      // set the value of the hardware
      (*(end_addresses[i]))->setVal(endAddress);
      
    }
    // initialize once for the entire bay
    _WebInit->execute();
    
  }

  return status;
}

//-------------------------------------------------------------------------------------
//IOCSH commands
//-------------------------------------------------------------------------------------

int waveformReaderConfigure(const char* portName, int bayNumber, int bufferSize, int waveformPVs)
{
  //WaveformReader *channelManager = new WaveformReader(portName, bayNumber, bufferSize, waveformPVs);
  //bayManager = channelManager;
  //WaveformReader* bayManager = WaveformReader::getPortDriver();
  WaveformReader* temp = new WaveformReader(portName, bayNumber, bufferSize, waveformPVs);
  WaveformReader::setPortDriver(temp);

  return asynSuccess;
}
static const iocshArg initArg0 = {"portName", iocshArgString};
static const iocshArg initArg1 = {"bayNumber", iocshArgInt};
static const iocshArg initArg2 = {"bufferSize", iocshArgInt};
static const iocshArg initArg3 = {"waveformPVs", iocshArgInt};
static const iocshArg * const initArgs[] = {&initArg0, &initArg1, &initArg2, &initArg3};
static const iocshFuncDef initFuncDef = {"waveformReaderConfigure", 4, initArgs};
static void initCallFunc(const iocshArgBuf *args)
{
  waveformReaderConfigure(args[0].sval, args[1].ival, args[2].ival, args[3].ival);
}

void waveformReaderRegister(void)
{
  iocshRegister(&initFuncDef, initCallFunc);
}

static void waveformStreamInit(std::string pvID, std::string file_path) {
  //bayManager->streamInit(pvID, file_path);
  WaveformReader* bayManager = WaveformReader::getPortDriver();
  bayManager->streamInit(pvID, file_path);
  return;
}

static const iocshArg streamArg0 = {"[channel]", iocshArgString};
static const iocshArg streamArg1 = {"[waveform pv ID]", iocshArgString};
static const iocshArg * const streamArgs[] = {&streamArg0, &streamArg1};
static const iocshFuncDef optFuncDef = {"waveformStreamInit", 2, streamArgs};
static void optCallFunc(const iocshArgBuf *args)
{
  waveformStreamInit(args[1].sval, args[0].sval);
}
void waveformStreamRegister(void)
{
  iocshRegister(&optFuncDef, optCallFunc);
}

static void waveformStatus(void)
{
  //bayManager->statusCheck();
  WaveformReader* bayManager = WaveformReader::getPortDriver();
  bayManager->statusCheck();
  return;
}
static const iocshFuncDef statusFuncDef = {"waveformStatus", 0};
static void statusCallFunc(const iocshArgBuf *args)
{
  waveformStatus();
}

void waveformStatusRegister(void)
{
  iocshRegister(&statusFuncDef, statusCallFunc);
}

static void printHelp() 
{
  std::cout << "Supported waveform commands:" << std::endl
    << "waveformStreamInit" << std::endl
    << "Usage: waveformStreamInit [channel] [waveform pv ID]" << std::endl
    << "[channel] is the path to the stream that cpsw can find, eg '/Stream0' " << std::endl
    << "[waveform pv ID] refers to the asyn string identifier for a given record, generally located in OUT or INP field" <<std::endl
    << std::endl
    << "waveformStatus" << std::endl
    << "Usage: waveformStatus" << std::endl
    << "Health check of initialized streams." << std::endl;
}

static const iocshFuncDef helpFuncDef = {"printHelp", 0};
static void helpCallFunc(const iocshArgBuf *args)
{
  printHelp();
}

void printHelpRegister(void)
{
  iocshRegister(&helpFuncDef, helpCallFunc);
}

static void fourierTransform(int waveformIndex)
{
  //bayManager->fft(waveformIndex);
  WaveformReader* bayManager = WaveformReader::getPortDriver();
  bayManager->fft(waveformIndex);
  return;
}

static const iocshArg fftArg0 = {"waveformIndex", iocshArgInt};
static const iocshArg * const fftArgs[] = {&fftArg0};
static const iocshFuncDef fftFuncDef = {"fourierTransform", 1, fftArgs};
static void fftCallFunc(const iocshArgBuf *args)
{
  fourierTransform(args[0].ival);
}

void fourierTransformRegister(void)
{
  iocshRegister(&fftFuncDef, fftCallFunc);
}


static void maxBeamLossLocation(int waveformIndex) {
  //bayManager->maxBeamLoss(waveformIndex);
  WaveformReader* bayManager = WaveformReader::getPortDriver();
  bayManager->maxBeamLoss(waveformIndex);
  return;
}

static const iocshArg lossArg0 = {"waveformIndex", iocshArgInt};
static const iocshArg * const lossArgs[] = {&lossArg0};
static const iocshFuncDef lossFuncDef = {"maxBeamLossLocation", 1, lossArgs};
static void lossCallFunc(const iocshArgBuf *args)
{
  maxBeamLossLocation(args[0].ival);
}
void maxBeamLossLocationRegister(void)
{
  iocshRegister(&lossFuncDef, lossCallFunc);
}


extern "C" {
  epicsExportRegistrar(printHelpRegister);
  epicsExportRegistrar(waveformStatusRegister);
  epicsExportRegistrar(waveformReaderRegister);
  epicsExportRegistrar(waveformStreamRegister);
  epicsExportRegistrar(fourierTransformRegister);
  epicsExportRegistrar(maxBeamLossLocationRegister);
}